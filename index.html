
<!doctype html>
<!--
================================================================================
Hide and Beep (Client)
--------------------------------------------------------------------------------
A mobile-first, browser-based outdoor multiplayer game inspired by hide-and-seek.

Gameplay summary
- Players join a shared room (identified by a 6-character code).
- One player is designated the HUNTER; the rest are HIDERS.
- HIDERS get a head-start ("Hiding time") to move away and hide.
- During the HUNT phase, the HUNTER receives proximity feedback via:
    - a distance readout (meters) to the nearest hider
    - a meter bar
    - audio beeps whose interval decreases as distance decreases
- The game ends when:
    - The hunter gets within â‰¤ 5 meters (auto-found), or
    - The hunter presses Tag (manual found), or
    - The host ends the game.

Important permissions and device requirements
- Location (GPS) access is mandatory for all players.
- Audio output is required for hunter beeps; vibration is optional.
- Best results outdoors with clear sky; accuracy > 50m pauses beeps.

Networking model (WebSocket)
- This client is written to use a WebSocket backend (WS_URL).
- In the current demo state, UI is usable without a backend:
    - simulateLocalCreate() generates a local room and player list
    - WebSocket messages are still sent but will be ignored if disconnected

File contents
- HTML: App screens (consent, home, create, join, lobby, countdown, hunt, end)
- CSS : Dark theme + reusable UI components (panels, buttons, badges)
- JS  : State management, GPS, distance/beep logic, basic spoof detection,
        wake lock handling, and WebSocket message handling.

Safety / privacy note
- Locations are intended to be shared only within the current game room.
- This client does not persist location data; storage is backend-dependent.

================================================================================
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hide and Beep</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f14" />
  manifest.json
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121822;
      --text: #e9f0f7;
      --muted: #9fb3c8;
      --accent: #27d3a2;
      --warn: #ffb020;
      --danger: #ff5a5f;
      --ok: #27d3a2;
      --btn: #1e2633;
      --btn-hover: #273041;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { max-width: 680px; margin: 0 auto; padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom); }
    header { padding: 16px 0 8px; display: flex; align-items: center; justify-content: space-between; }
    .brand { font-size: 1.25rem; font-weight: 700; letter-spacing: .3px; }
    .status-pill { font-size: .85rem; padding: 6px 10px; border-radius: 999px; background: #1a232f; color: var(--muted); }
    .panel { background: var(--panel); border: 1px solid #1c2632; border-radius: 12px; padding: 16px; margin: 12px 0; }
    h1, h2, h3 { margin: 0 0 8px; }
    p { margin: 4px 0 10px; color: var(--muted); }
    .row { display: flex; gap: 10px; flex-wrap: wrap; }
    .btn {
      background: var(--btn); color: var(--text); border: 1px solid #2b3650; border-radius: 10px;
      padding: 12px 14px; font-weight: 600; cursor: pointer; transition: background .15s, transform .02s;
    }
    .btn:hover { background: var(--btn-hover); }
    .btn:active { transform: translateY(1px); }
    .btn-primary { background: #1a3a2f; border-color: #2a5d4b; }
    .btn-accent { background: #0f2a22; border-color: #1f4f42; color: #8cf5db; }
    .btn-danger { background: #341318; border-color: #602229; color: #ffb8bc; }
    input, select { background: #0f141c; color: var(--text); border: 1px solid #263246; border-radius: 10px; padding: 10px 12px; width: 100%; }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; letter-spacing: .5px; }
    .hidden { display: none !important; }
    .badge { display: inline-block; padding: 4px 8px; border-radius: 999px; background: #15202b; color: var(--muted); font-size: .8rem; border: 1px solid #213047; }
    .grid { display: grid; gap: 10px; }
    .grid.two { grid-template-columns: 1fr 1fr; }
    .meter {
      --pct: 0%;
      height: 12px; background: #0d121a; border: 1px solid #203046; border-radius: 999px; overflow: hidden;
      position: relative;
    }
    .meter::after {
      content:''; position:absolute; inset:0; width: var(--pct);
      background: linear-gradient(90deg, #2759ff, #27d3a2);
      transition: width .2s;
    }
    .callout { padding: 10px 12px; border-radius: 12px; background: #0e1520; border: 1px dashed #2a3a54; color: var(--muted); }
    .warn { color: var(--warn); }
    .danger { color: var(--danger); }
    .ok { color: var(--ok); }
    footer { opacity: .6; font-size: .85rem; padding: 12px 0 30px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">ðŸ”Š Hide and Beep</div>
      <div id="connStatus" class="status-pill">WS: <span class="danger">Disconnected</span></div>
    </header>
 <!--
    ============================================================================
    CONSENT / PERMISSIONS VIEW
    ----------------------------------------------------------------------------
    Purpose:
    - Explain what permissions are needed (Location + Audio) and why.
    - Ensure the first user gesture unlocks audio playback in mobile browsers.
    Notes:
    - AudioContext creation typically requires a user interaction.
    - Location permission is requested when geolocation.watchPosition starts.
    ============================================================================
    -->

    <!-- CONSENT -->
    <section id="view-consent" class="panel">
      <h2>Permissions</h2>
      <p><strong>Location &amp; Audio</strong></p>
      <p>Hide and Beep shares your live location with players in your current game room only. Data isnâ€™t stored after the game ends.<br/>Weâ€™ll request access to your location and enable short beeps and vibration for distance feedback.</p>
      <div class="row">
        <button id="btnConsentAgree" class="btn btn-primary">I Agree</button>
        <button id="btnConsentCancel" class="btn">Cancel</button>
      </div>
      <div id="permMsg" class="callout hidden"></div>
    </section>

    <!--
    ============================================================================
    HOME VIEW
    ----------------------------------------------------------------------------
    Entry point after the user agrees to permissions.
    Allows the player to:
    - Create a new game room
    - Join an existing room by code
    ============================================================================
    -->

    <!-- HOME -->
    <section id="view-home" class="panel hidden">
      <h2>Start</h2>
      <div class="grid two">
        <button id="btnCreate" class="btn btn-accent">Create Game</button>
        <button id="btnJoin" class="btn">Join Game</button>
      </div>
      <p class="callout">Audio will start after your first tap. Best played outdoors with clear sky for GPS.</p>
    </section>
<!--
    ============================================================================
    CREATE GAME VIEW
    ----------------------------------------------------------------------------
    Collects a display name and creates a new room.
    In the current demo version, room creation is simulated locally until a
    WebSocket backend is connected (simulateLocalCreate()).
    ============================================================================
    -->

    <!-- CREATE -->
    <section id="view-create" class="panel hidden">
      <h2>Create Game</h2>
      <div class="grid">
        <label>Display name
          <input id="createName" placeholder="Your name" maxlength="20" />
        </label>
        <div class="row">
          <button id="btnCreateGo" class="btn btn-primary">Create</button>
          <button class="btn" data-nav="home">Back</button>
        </div>
      </div>
    </section>
  <!--
    ============================================================================
    JOIN GAME VIEW
    ----------------------------------------------------------------------------
    Collects:
    - Display name
    - 6-character room code (e.g., ABC123)
    In the current demo version, join is simulated locally if backend is absent.
    ============================================================================
    -->

    <!-- JOIN -->
    <section id="view-join" class="panel hidden">
      <h2>Join Game</h2>
      <div class="grid">
        <label>Display name
          <input id="joinName" placeholder="Your name" maxlength="20" />
        </label>
        <label>Game code
          <input id="joinCode" class="code" placeholder="ABC123" maxlength="6" />
        </label>
        <div class="row">
          <button id="btnJoinGo" class="btn btn-primary">Join</button>
          <button class="btn" data-nav="home">Back</button>
        </div>
      </div>
    </section>
 <!--
    ============================================================================
    LOBBY VIEW
    ----------------------------------------------------------------------------
    Host controls:
    - Share room code
    - Choose hiding time (head start)
    - Select the Hunter
    From here the host starts the game, transitioning players into countdown.
    ============================================================================
    -->

    <!-- LOBBY -->
    <section id="view-lobby" class="panel hidden">
      <h2>Lobby</h2>
      <p>Share your code:</p>
      <div class="row">
        <div class="badge code" id="roomCode">------</div>
        <button id="btnCopyCode" class="btn">Copy</button>
      </div>
      <div class="panel">
        <h3>Players</h3>
        <ul id="playerList"></ul>
      </div>
      <div class="grid two">
        <label>Hiding time
          <select id="hideTime">
            <option value="60">1 min</option>
            <option value="120">2 min</option>
            <option value="300">5 min</option>
          </select>
        </label>
        <label>Hunter
          <select id="hunterSelect"></select>
        </label>
      </div>
      <div class="row">
        <button id="btnStartGame" class="btn btn-accent">Start</button>
        <button class="btn btn-danger" id="btnLeaveLobby">Leave</button>
      </div>
    </section>
 <!--
    ============================================================================
    COUNTDOWN (HIDING) VIEW
    ----------------------------------------------------------------------------
    The hiding phase gives hiders time to move away and hide.
    When the countdown hits 0, the client transitions to the hunt view.
    ============================================================================
    -->

    <!-- COUNTDOWN -->
    <section id="view-countdown" class="panel hidden">
      <h2>Hidingâ€¦</h2>
      <p>Time remaining:</p>
      <div class="badge" id="countdownBadge">â€”</div>
      <div class="row">
        <button id="btnCancelStart" class="btn">Cancel</button>
      </div>
    </section>
<!--
    ============================================================================
    HUNT VIEW
    ----------------------------------------------------------------------------
    The active gameplay screen.
    Hunter:
    - sees nearest distance to any hider
    - receives proximity beeps (interval mapped from distance)
    Hider:
    - sees role and GPS status but no proximity cues
    ============================================================================
    -->

    <!-- HUNT -->
    <section id="view-hunt" class="panel hidden">
      <h2>Hunt</h2>
      <div class="grid two">
        <div class="panel">
          <div>Role: <span id="roleLabel" class="badge">â€”</span></div>
          <div>GPS: <span id="gpsStatus" class="badge">â€”</span></div>
          <div>Spoofing: <span id="spoofStatus" class="badge">None</span></div>
        </div>
        <div class="panel">
          <div>Nearest distance</div>
          <div style="font-size:2rem; font-weight:800;"><span id="distNum">â€”</span> m</div>
          <div class="meter" id="distMeter" style="--pct:0%;"></div>
          <div class="badge">Beep: <span id="beepInterval">â€”</span> ms</div>
        </div>
      </div>
      <div id="hunterControls" class="panel hidden">
        <button id="btnTag" class="btn btn-primary">Tag (I found someone)</button>
      </div>
      <div id="warnings" class="callout hidden"></div>
      <div class="row">
        <button id="btnEndGame" class="btn btn-danger">End Game</button>
      </div>
    </section>
<!--
    ============================================================================
    END VIEW (GAME OVER)
    ----------------------------------------------------------------------------
    Shows end-of-game summary and provides:
    - Rematch (returns to lobby state)
    - Exit (returns to home state)
    ============================================================================
    -->

    <!-- END -->
    <section id="view-end" class="panel hidden">
      <h2>Game Over</h2>
      <div id="endSummary" class="callout">â€”</div>
      <div class="row">
        <button id="btnRematch" class="btn btn-accent">Rematch</button>
        <button id="btnExit" class="btn">Exit</button>
      </div>
    </section>

    <footer>
      <div>Meters only Â· 1s GPS updates Â· Fixed 800â€¯Hz/200â€¯ms beep Â· Auto found at â‰¤5â€¯m + manual Tag</div>
    </footer>
  </div>

  <script>
  // =========================
  // Configuration & Constants
  // =========================
  const WS_URL = 'wss://YOUR-WEBSOCKET-ENDPOINT.example'; // TODO: Point to Cloudflare Worker later
  const UPDATE_INTERVAL_MS = 1000; // GPS + logic update cadence
  const FOUND_THRESHOLD_M = 5;     // auto-found
  const DIST_CAP_FOR_BEEP = 500;   // cap for beep mapping (numeric distance still shows actual)
  const AUDIO_FREQ_HZ = 800;
  const BEEP_MS = 200;

  // 5-step thresholds (meters -> interval ms)
  // Converts a distance into an audio beep
  // Smaller interval =>faster beeps => closer to hider
  function intervalForDistance(m) {
    const d = Math.min(m, DIST_CAP_FOR_BEEP);
    if (d >= 500) return 1500;
    if (d >= 200) return 1000;
    if (d >= 100) return 600;
    if (d >= 20)  return 400;
    return 200;
  }

  // =========================
  // App State
  // =========================
  const app = {
    view: 'consent', 
    // Current visible view/screen in the single-page UI
    // consent|home|create|join|lobby|countdown|hunt|end
    me: { id: null, name: '', role: 'hider' }, // role: 'hunter' | 'hider'
    room: { code: null, players: [] },
    hideSeconds: 60,
    countdownEndTs: 0,
    ws: null, wsReady: false,
    geoWatchId: null,
    lastFixes: [], // for smoothing: [{lat,lon,ts,acc}]
    lastGoodFix: null,
    spoofFlag: false,
    lastRemotePositions: {}, // playerId -> {lat,lon,ts}
    audioUnlocked: false,
    wakeLock: null,
    beepTimer: null,
    lastBeepInterval: null,
    lastBeepAt: 0,
    roleIsHunter() { return app.me.role === 'hunter'; },
  };

  // =========================
  // Utilities
  // =========================
  function $(sel) { return document.querySelector(sel); }
  function show(id) { document.querySelectorAll('section').forEach(s => s.id === id ? s.classList.remove('hidden') : s.classList.add('hidden')); app.view = id.replace('view-', ''); }
  // UI router: show exactly one <section> by id (e.g., 'view-home')
  // and hide all others.
  function setText(id, v) { const el = $(id); if (el) el.textContent = v; }
  function setBadge(id, v, cls) {
    const el = $(id);
    if (!el) return;
    el.textContent = v;
    el.className = 'badge' + (cls ? ' ' + cls : '');
  }
  function clamp(n, a, b){ return Math.max(a, Math.min(n, b)); }
  function codeGen(){ const a='ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; let s=''; for(let i=0;i<6;i++) s += a[Math.floor(Math.random()*a.length)]; return s; }

  // Haversine distance in meters
  // Computes great-circle distance between two GPS coordinates.
  // This is more accurate than simple planar approximations for real-world use.
  function haversine(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = d => d*Math.PI/180;
    const dLat = toRad(lat2-lat1);
    const dLon = toRad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    return 2 * R * Math.asin(Math.sqrt(a));
  }

  // Basic smoothing (last 3 fixes)
  // Reduces jitter by averaging the last few GPS fixes.
  // Note: This is a simple mean filter; more advanced approaches could use
  // a Kalman filter or accuracy-weighted smoothing.
  function smoothedFix() {
    if (app.lastFixes.length === 0) return null;
    const arr = app.lastFixes.slice(-3);
    const lat = arr.reduce((s,f)=>s+f.lat,0)/arr.length;
    const lon = arr.reduce((s,f)=>s+f.lon,0)/arr.length;
    const acc = arr.reduce((s,f)=>s+ (f.acc||0),0)/arr.length;
    return { lat, lon, acc, ts: arr[arr.length-1].ts };
  }

  // Spoof detection: high speed (> 60 km/h) or huge jump (> 200 m) between 1s ticks
  // Purpose:
  // - Discourage GPS spoofing or unrealistic movement that breaks gameplay.
  // - If flagged, beeps are paused and a warning is displayed.
  // Heuristics:
  // - Jump > 200m within ~1s, OR speed > 60 km/h.

  function spoofCheck(prev, curr) {
    if (!prev || !curr) return false;
    const d = haversine(prev.lat, prev.lon, curr.lat, curr.lon);
    const dt = Math.max(1, (curr.ts - prev.ts)/1000);
    const speedKmh = (d/1000) / (dt/3600);
    return (d > 200) || (speedKmh > 60);
  }

  function updateMeter(m, min=0, max=DIST_CAP_FOR_BEEP) {
    const pct = clamp(1 - (Math.min(m, max) / max), 0, 1) * 100;
    const el = $('#distMeter');
    el.style.setProperty('--pct', pct.toFixed(1) + '%');
  }

  // =========================
  // Audio & Haptics (simple)
  // =========================
  let audioCtx = null;
  function unlockAudio() {
  // Mobile browsers often require a user gesture before audio can play.
  // This function creates an AudioContext and plays a near-silent tick to
  // satisfy gesture policies, enabling later beeps.
    if (app.audioUnlocked) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      // create a silent buffer to satisfy gesture policies
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      g.gain.value = 0.0001;
      o.connect(g).connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + 0.01);
      app.audioUnlocked = true;
    } catch (e) {
      // ignore
    }
  }

  function beep(durationMs=BEEP_MS, freq=AUDIO_FREQ_HZ) {
    // Emits a short sine-wave beep plus optional vibration.
    // Frequency and duration are fixed by constants for consistent feedback.
    if (!audioCtx) return;
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = freq;
    g.gain.setValueAtTime(0.001, now);
    g.gain.exponentialRampToValueAtTime(0.3, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, now + durationMs/1000);
    o.connect(g).connect(audioCtx.destination);
    o.start(now);
    o.stop(now + durationMs/1000);

    // Haptics
    if (navigator.vibrate) navigator.vibrate(durationMs);
  }

  function setBeepInterval(ms) {
   // Reconfigures the repeating beep timer.
   // We clear and recreate the interval whenever the distance band changes.
    setText('#beepInterval', ms);
    if (app.beepTimer) { clearInterval(app.beepTimer); app.beepTimer = null; }
    app.lastBeepInterval = ms;
    if (app.roleIsHunter() && !app.spoofFlag) {
      app.beepTimer = setInterval(() => {
        // Only beep if we have a recent fix and GPS ok
        const ok = !!app.lastGoodFix && (!$('#warnings').textContent.includes('GPS accuracy poor'));
        if (ok) beep();
      }, ms);
    }
  }

  // =========================
  // Wake Lock
  // =========================
  async function requestWakeLock() {
    try {
      if ('wakeLock' in navigator) {
        app.wakeLock = await navigator.wakeLock.request('screen');
        app.wakeLock.addEventListener('release', ()=>{ /* no-op */ });
      }
    } catch (e) { /* ignore */ }
  }

  // =========================
  // WebSocket (stubbed)
  // =========================
  function wsConnect() {
    try {
      app.ws = new WebSocket(WS_URL);
      app.ws.addEventListener('open', () => {
        app.wsReady = true;
        $('#connStatus').innerHTML = 'WS: <span class="ok">Connected</span>';
        // If already in a room, rejoin
        if (app.room.code && app.me.id) {
          wsSend({ t:'rejoin', room: app.room.code, id: app.me.id, name: app.me.name });
        }
      });
      app.ws.addEventListener('close', () => {
        app.wsReady = false;
        $('#connStatus').innerHTML = 'WS: <span class="danger">Disconnected</span>';
        setTimeout(wsConnect, 3000);
      });
      app.ws.addEventListener('error', () => {
        app.wsReady = false;
        $('#connStatus').innerHTML = 'WS: <span class="danger">Disconnected</span>';
      });
      app.ws.addEventListener('message', ev => {
        try { handleWs(JSON.parse(ev.data)); } catch(e) {}
      });
    } catch (e) {
      $('#connStatus').innerHTML = 'WS: <span class="danger">Disconnected</span>';
    }
  }
  function wsSend(obj) {
    if (app.wsReady) app.ws.send(JSON.stringify(obj));
  }
  function handleWs(msg) {
    switch (msg.t) {
      case 'welcome':
        app.me.id = msg.id;
        break;
      case 'room':
        app.room.code = msg.room;
        $('#roomCode').textContent = app.room.code;
        break;
      case 'players':
        app.room.players = msg.players;
        renderPlayers();
        break;
      case 'start':
        app.me.role = msg.roleMap[app.me.id] || 'hider';
        setText('#roleLabel', app.me.role.toUpperCase());
        app.countdownEndTs = Date.now() + (msg.hideSeconds*1000);
        show('view-countdown');
        break;
      case 'hunt':
        // signal to enter hunt screen now
        show('view-hunt');
        setText('#roleLabel', app.me.role.toUpperCase());
        break;
      case 'positions':
        app.lastRemotePositions = msg.positions || {};
        break;
      case 'found':
        endGameSummary(msg.summary || 'Found!');
        break;
      case 'end':
        endGameSummary(msg.summary || 'Game ended.');
        break;
    }
  }

  // For UI demo without backend: local fake IDs and immediate lobby display
  function simulateLocalCreate() {
    app.me.id = app.me.id || ('me-' + Math.random().toString(36).slice(2));
    app.room.code = app.room.code || codeGen();
    $('#roomCode').textContent = app.room.code;
    app.room.players = [{ id: app.me.id, name: app.me.name }];
    renderPlayers();
  }

  // =========================
  // GPS Handling
  // =========================
  function startGeo() {
 // Begins continuous GPS tracking using watchPosition.
 // Uses high accuracy mode; a short maximumAge keeps fixes fresh.
    if (!('geolocation' in navigator)) {
      warn('Geolocation not supported.');
      setBadge('#gpsStatus','Unsupported','danger');
      return;
    }
    try {
      if (app.geoWatchId) navigator.geolocation.clearWatch(app.geoWatchId);
      app.geoWatchId = navigator.geolocation.watchPosition(onGeo, onGeoErr, {
        enableHighAccuracy: true,
        maximumAge: 500,
        timeout: 6000,
      });
      setBadge('#gpsStatus','Watching','ok');
    } catch (e) {
      warn('Failed to start GPS.');
      setBadge('#gpsStatus','Error','danger');
    }
  }

  function onGeo(pos) {
    // Called on each GPS update.
    // Responsibilities:
    // - Store fix history and compute smoothed fix
    // - Gate gameplay on accuracy (pause beeps if accuracy is poor)
    // - Run spoof detection heuristics
    // - Broadcast position to the server
    // - If hunter: compute nearest distance and map to beep interval
    const { latitude:lat, longitude:lon, accuracy } = pos.coords;
    const ts = pos.timestamp || Date.now();
    const fix = { lat, lon, acc: accuracy, ts };
    app.lastFixes.push(fix);
    if (app.lastFixes.length > 10) app.lastFixes.shift();

    const sm = smoothedFix();
    // Accuracy gate: if accuracy > 50m, pause beeps and warn
    const poor = (sm && sm.acc && sm.acc > 50);
    if (poor) {
      warn('GPS accuracy poor (>50 m). Beep paused.');
    } else {
      clearWarn();
      app.lastGoodFix = sm || fix;
    }

    // Spoof check against last good fix
    app.spoofFlag = spoofCheck(app.lastGoodFix, sm || fix);
    setBadge('#spoofStatus', app.spoofFlag ? 'Suspected' : 'None', app.spoofFlag ? 'danger' : '');
    if (app.spoofFlag) {
      warn('Unrealistic movement detected. Beep paused.');
    }

    // Broadcast position
    wsSend({ t: 'pos', room: app.room.code, id: app.me.id, lat: fix.lat, lon: fix.lon, ts });

    // Update distance/beep for hunter
    if (app.roleIsHunter()) {
      const d = nearestDistanceMeters();
      if (d != null) {
        setText('#distNum', Math.round(d));
        updateMeter(d);
        const intv = intervalForDistance(d);
        if (intv !== app.lastBeepInterval) setBeepInterval(intv);
      } else {
        setText('#distNum','â€”');
        setBeepInterval(1000);
      }
    }
  }

  function onGeoErr(err) {
    warn('Location error: ' + err.message);
    setBadge('#gpsStatus','Error','danger');
  }

  function warn(msg) {
    const w = $('#warnings'); w.textContent = msg; w.classList.remove('hidden');
    if (app.beepTimer) { clearInterval(app.beepTimer); app.beepTimer = null; }
  }
  function clearWarn() {
    const w = $('#warnings'); w.textContent = ''; w.classList.add('hidden');
    if (app.roleIsHunter() && app.lastBeepInterval) {
      setBeepInterval(app.lastBeepInterval);
    }
  }

  function nearestDistanceMeters() {
    // Computes the smallest distance from 'me' to any other player's last known
    // position. Hunter feedback uses this nearest value.

    const me = app.lastGoodFix;
    if (!me) return null;
    let best = null;
    for (const [pid, p] of Object.entries(app.lastRemotePositions)) {
      if (pid === app.me.id) continue;
      if (!p || typeof p.lat !== 'number' || typeof p.lon !== 'number') continue;
      const d = haversine(me.lat, me.lon, p.lat, p.lon);
      if (best == null || d < best) best = d;
    }
    return best;
  }

  // =========================
  // UI Actions
  // =========================
  $('#btnConsentAgree').addEventListener('click', async () => {
    unlockAudio();
    await requestWakeLock();
    show('view-home');
  });
  $('#btnConsentCancel').addEventListener('click', () => {
    $('#permMsg').classList.remove('hidden');
    $('#permMsg').textContent = 'You can come back anytime when youâ€™re ready.';
  });

  document.querySelectorAll('[data-nav]').forEach(b => b.addEventListener('click', e => {
    const v = e.currentTarget.getAttribute('data-nav');
    if (v === 'home') show('view-home');
  }));

  $('#btnCreate').addEventListener('click', () => show('view-create'));
  $('#btnJoin').addEventListener('click', () => show('view-join'));

  $('#btnCreateGo').addEventListener('click', () => {
    const name = $('#createName').value.trim() || 'Player';
    app.me.name = name;
    simulateLocalCreate(); // until backend ready
    show('view-lobby');
  });

  $('#btnJoinGo').addEventListener('click', () => {
    const name = $('#joinName').value.trim() || 'Player';
    const code = $('#joinCode').value.trim().toUpperCase();
    app.me.name = name;
    app.room.code = code || codeGen(); // allow empty for local test
    simulateLocalCreate(); // until backend ready
    show('view-lobby');
  });

  $('#btnCopyCode').addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText($('#roomCode').textContent);
      $('#btnCopyCode').textContent = 'Copied';
      setTimeout(()=>$('#btnCopyCode').textContent='Copy', 1000);
    } catch (e) {}
  });

  $('#btnStartGame').addEventListener('click', () => {
    // Host picks hunter & hide time
    const hideSeconds = parseInt($('#hideTime').value, 10);
    app.hideSeconds = hideSeconds;
    const hunterId = $('#hunterSelect').value || app.room.players[0]?.id;
    app.me.role = (app.me.id === hunterId) ? 'hunter' : 'hider';
    setText('#roleLabel', app.me.role.toUpperCase());
    app.countdownEndTs = Date.now() + hideSeconds*1000;
    show('view-countdown');
    // Broadcast
    wsSend({ t:'start', room: app.room.code, hideSeconds, hunterId });
    startUpdateLoop();
  });

  $('#btnLeaveLobby').addEventListener('click', () => {
    wsSend({ t:'leave', room: app.room.code, id: app.me.id });
    resetToHome();
  });

  $('#btnCancelStart').addEventListener('click', () => {
    wsSend({ t:'cancelStart', room: app.room.code });
    show('view-lobby');
  });

  $('#btnEndGame').addEventListener('click', () => {
    wsSend({ t:'end', room: app.room.code });
    endGameSummary('Ended by host.');
  });

  $('#btnTag').addEventListener('click', () => {
    // Manual found
    wsSend({ t:'tag', room: app.room.code, id: app.me.id });
    endGameSummary('Hunter tagged a hider.');
  });

  $('#btnRematch').addEventListener('click', () => {
    show('view-lobby');
    clearHunt();
  });

  $('#btnExit').addEventListener('click', () => {
    resetToHome();
  });

  function startUpdateLoop() {
    // Starts the main 1-second loop (UPDATE_INTERVAL_MS).
    // This loop drives:
    // - countdown display
    // - periodic position broadcast (smoothed)
    // - auto-found detection when hunter is very close
    $('#hunterControls').classList.toggle('hidden', !app.roleIsHunter());
    startGeo();
    requestWakeLock();
    // countdown tick
    const tick = () => {
      if (app.view === 'countdown') {
        const left = Math.max(0, Math.ceil((app.countdownEndTs - Date.now())/1000));
        setText('#countdownBadge', left + 's');
        if (left <= 0) {
          // move to hunt
          show('view-hunt');
          setText('#roleLabel', app.me.role.toUpperCase());
        }
      }
      // broadcast last good fix every tick too
      const sm = smoothedFix();
      if (sm) {
        wsSend({ t:'pos', room: app.room.code, id: app.me.id, lat: sm.lat, lon: sm.lon, ts: sm.ts });
      }
      // auto-found for hunter if close enough
      if (app.view === 'hunt' && app.roleIsHunter()) {
        const d = nearestDistanceMeters();
        if (d != null && d <= FOUND_THRESHOLD_M) {
          wsSend({ t:'found', room: app.room.code });
          endGameSummary('Auto-found within 5 m!');
        }
      }
    };
    if (app._interval) clearInterval(app._interval);
    app._interval = setInterval(tick, UPDATE_INTERVAL_MS);
  }

  function renderPlayers() {
    const ul = $('#playerList');
    ul.innerHTML = '';
    for (const p of app.room.players) {
      const li = document.createElement('li');
      li.textContent = p.name + (p.id === app.me.id ? ' (you)' : '');
      ul.appendChild(li);
    }
    // Hunter select
    const sel = $('#hunterSelect');
    sel.innerHTML = '';
    for (const p of app.room.players) {
      const opt = document.createElement('option');
      opt.value = p.id;
      opt.textContent = p.name;
      sel.appendChild(opt);
    }
    sel.value = sel.options[0]?.value || '';
  }

  function clearHunt() {
     // Resets hunt-specific runtime state (GPS watcher, beep timers, caches).
    // Called when ending a game or leaving a room.
    if (app.beepTimer) { clearInterval(app.beepTimer); app.beepTimer = null; }
    if (app.geoWatchId) { navigator.geolocation.clearWatch(app.geoWatchId); app.geoWatchId = null; }
    app.lastFixes = [];
    app.lastRemotePositions = {};
    app.spoofFlag = false;
    setBadge('#spoofStatus','None');
    setText('#distNum','â€”');
    setBeepInterval(1000);
  }

  function resetToHome() {
    // Returns to initial playable state after leaving a room.
    // Clears hunt state and room data.
    clearHunt();
    app.room = { code: null, players: [] };
    app.me.role = 'hider';
    show('view-home');
  }

  function endGameSummary(text) {
    clearHunt();
    setText('#endSummary', text);
    show('view-end');
  }

  // Init
  wsConnect(); // will retry if unavailable
  show('view-consent');
   </script>
</body>
